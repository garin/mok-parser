#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.10
# from Racc grammer file "".
#

require 'racc/parser.rb'

require "parserutility"
require "mokinlineparser.tab"
require "mokelement"
require "erb"

module Mok

class BlockParser < Racc::Parser

module_eval(<<'...end mokblockparser.ry/module_eval...', 'mokblockparser.ry', 128)
include ParserUtility

class Line
  def initialize(line)
    @content = line
#    @indent  = get_line_indent(line)
    #    @type    = nil
  end
  attr_reader :indent, :no
  attr_accessor :type, :content
  alias indent_size indent

  def get_line_indent
    return 0 if @content.nil?
    @content =~ /(\s*)/
    $1.size
  end
  alias indent get_line_indent
end


def initialize(options = {})
  @options = options
  @inline_parser = InlineParser.new(options)
  @metadata = {}
  @inline_index = @inline_parser.index
  @index = {}
  @head_index = HeadIndex.new
end
attr_reader :metadata, :inline_index, :index

def parse(src)
  @no = 0
  # srcをerbで処理
  src = ERB.new(src.join,4).result(binding.taint).split("\n").map {|s| "#{s}\n"}

  # 部分テンプレート(partial)
  src = insert_partial(src)

  @src = Array(src)
  @line = Line.new("")
  @line_pre = @line.dup
  @indent_stack = []
  @current_indent = 0
  @current_type = :header
  @yydebug = true
  @view_token_type = false
  do_parse
end

def on_error(token_id, value, stack)
  lineno = @src[0..@no].to_s.split("\n").size
  raise Racc::ParseError,
        "mokblockpaser: line #{lineno}: syntax error on #{value.inspect}"
end

def next_token
  @line_pre = @line.dup
  @line = Line.new(@src[@no])
#  puts "line: #{@line.content}" if @view_token_type
  case @line.content
  when nil
      @line.content = ""
      if_current_indent_equal("") do
        puts "b: false: #{@line.content}" if @view_token_type
        [false, false]
      end
  when /^$/
    @line.content = ""
    if_current_indent_equal("") do
      if @current_type == :preformat
        puts "b: :PREFORMAT: #{@line.content}" if @view_token_type
        [:PREFORMAT, "\n"]
      elsif @current_type == :quote
        puts "b: :QUOTE: #{@line.content}" if @view_token_type
        [:QUOTE, "\n"]
      elsif @current_type == :descline
        puts "b: DESCLINE: #{@line.content}" if @view_token_type
        [:DESCLINE, " "]
      else
        puts "b: WHITELINE: #{@line.content}" if @view_token_type
        @current_type = :whiteline
        [:WHITELINE, :WHITELINE]
      end
    end
  when /^\#(.*)/  # comment line
    @no += 1
    if @current_type == :header
      puts "b: HEADER: #{@line.content}" if @view_token_type
      [:HEADER, $1.strip]
    else
      puts "b: COMMENT(noop): #{@line.content}" if @view_token_type
      next_token
    end
  when /^(={1,4})(?!=)\s*(?=\S)/, /^(\+{1,2})(?!\+)\s*(?=\S)/
    rest = $'                    # '
    rest.strip!
    mark = $1
    #    if_current_indent_equal("") do
    if_current_indent_equal(@line.indent) do
      @current_type = :headline
      puts "b: HEADLINE: #{@line.content}" if @view_token_type
      [:HEADLINE, [mark_to_level(mark), rest]]
    end
  when /^\s\s+(.*)/    # type == preformat
    puts "b: 2 WHITE SPACE(#{@current_type}) : #{@line.content}" if @view_token_type
    case @current_type
    when :itemlist
      if @line.content =~ /^(\s*)(\*)(\s+)(.*)/
        line = $4.strip
        if line.empty?
          @no += 1
          next_token
        else
          if_current_indent_equal(@line.indent) do
            puts "b: ITEMLIST: [#{line}]" if @view_token_type
            @current_type = :itemlist
            [:ITEMLIST, line]
          end
        end
      else
        line = @line.content.strip
        if line.empty?
          @no += 1
          next_token
        else
          puts "b: ITEMLISTCONTINUE: [#{line.empty?}] --" if @view_token_type
          @no += 1
          @current_type = :itemlist
          [:ITEMLISTCONTINUE, line]
        end
      end
    when :numlist
      @line.content =~ /^(\s*)(\(\d+\))(\s+)(.*)/
      if $4.nil?
        @line.content =~ /^(\s*)(\d\.)(\s+)(.*)/
      end
      line = $4
      line ||= @line.content.strip
      if line.empty?
        @no += 1
        next_token
      else
        if_current_indent_equal(@line.indent) do
          puts "b: NUMLIST: [#{line}]" if @view_token_type
          @current_type = :numlist
          [:NUMLIST, line]
        end
      end
    else
      @no += 1
      if @current_type == :descline
        @current_type = :descline
        puts "b: DESCLINE: #{@line.content}" if @view_token_type
        [:DESCLINE, $1 + "\n"]
      else
        @current_type = :preformat
        puts "b: PREFORMAT: #{$1}" if @view_token_type
        [:PREFORMAT, @line.content.sub("  ","")]
      end
    end
  when /^>\s(.*)/    # type == quote
    puts "b: 2 WHITE SPACE(#{@current_type}) : #{@line.content}" if @view_token_type
    @current_type = :quote
    puts "b: QUOTE: #{$1}" if @view_token_type
    if_current_indent_equal(@line.indent) do
      [:QUOTE, @line.content.sub("> ","")]
    end
  when /^(\:)(.*)/ # type = desclist
   if_current_indent_equal(@line.indent) do
      @current_type = :descline
      puts "b: DESCLINE_TILTE: #{$2.strip}" if @view_token_type
      [:DESCLINE_TITLE, $2.strip]
    end
  when /^(\s*)(\*)(\s+)(.*)/ # type = itemlist
    if_current_indent_equal(@line.indent) do
        puts "b: ITEMLIST: #{@line.content}" if @view_token_type
        @current_type = :itemlist
        [:ITEMLIST, $4]
    end
  when /^(\s*)(\(\d+\))(\s+)(.*)/
    if_current_indent_equal(@line.indent) do
        puts "b: NUMLIST: #{@line.content}" if @view_token_type
        @current_type = :numlist
        [:NUMLIST, $4]
    end
  when  /^(\s*)(\d+\.)(\s+)(.*)/ # type = numlist
    if_current_indent_equal(@line.indent) do
        puts "b: NUMLIST: #{@line.content}" if @view_token_type
        @current_type = :numlist
        [:NUMLIST, $4]
    end
  when /^\|-.*/			# type = table head
    # テーブル内であればテーブルヘッダとして無視、そうでなければ普通のPLAINとして扱う
    if @current_type == :table
      @no += 1
      next_token
    else
      @current_type = :plain
      if_current_indent_equal(@line.indent) do
        puts "b: PLAIN: #{@line.content}" if @view_token_type
        [:PLAIN, @line.content]
      end
    end
  when /^\|.*/ # type = table
    @no += 1
    @current_type = :table
    lines = @line.content.chomp.split("|")
    lines.shift
    [:TABLELINE, lines]
  when /(.*)/    # type == plain
    @current_type = :plain
    if_current_indent_equal(@line.indent) do
      puts "b: PLAIN: #{@line.content}" if @view_token_type
      [:PLAIN, @line.content]
    end
  else
    puts "raise : #{@line}"
  end
end

def if_current_indent_equal(ident)
  indent_space = 2
  puts "current: #{@current_indent}, line: #{@line.indent}, stack #{@indent_stack.size}:" if @view_token_type
  indent_sabun = @current_indent - @line.indent
  if indent_sabun >= -1 and indent_sabun <= 1
    @no += 1
    yield
  elsif @current_indent < @line.indent
    ((@line.indent - @current_indent) / indent_space).times do
      @indent_stack.push("")
    end
    @current_indent = @line.indent
    puts "b: INDENT" if @view_token_type
    [:INDENT, :INDENT]
  else
    @indent_stack.pop
    @current_indent = @line.indent if @line.indent == @indent_stack.size * indent_space
    puts "b: DEDENT" if @view_token_type
    [:DEDENT, :DEDENT]
  end
end

def insert_partial(src)
  src.map do |line|
    if line =~ /^\(\(\!(.*?)\!\)\)/
      file = File.join(File.dirname($1), "_#{File.basename($1)}.mok")
      file_path = file
      file_path = File.join(File.dirname(@options[:src_file]),file) if @options[:src_file]
      unless @options[:partial_base_directory].nil?
        file_path = File.join(@options[:partial_base_directory],file) unless @options[:partial_base_directory].empty?
      end
      if File.exist?(file_path)
        File.open(file_path).readlines
      else
        ["((*Warning*)): [partial] #{file} is not found\n"]
      end
    else
      line
    end
  end.flatten
end

...end mokblockparser.ry/module_eval...
##### State transition tables begin ###

racc_action_table = [
    14,    13,    15,    17,    18,    40,    20,    22,    26,    32,
    28,    52,    32,    34,    14,    13,    15,    17,    18,    40,
    20,    22,    26,    32,    28,    41,    32,    34,    40,    56,
    50,    26,    32,    28,    38,    32,    28,    38,    55,    28,
    38,    51,    28,    28,    53,    43,    45,    54,    44,    35,
    57 ]

racc_action_check = [
     0,     0,     0,     0,     0,    40,     0,     0,     0,    40,
     0,    33,     0,     0,     2,     2,     2,     2,     2,     9,
     2,     2,     2,     9,     2,    16,     2,     2,    48,    48,
    28,    26,    48,    26,    38,    26,    38,    47,    47,    47,
     8,    30,     8,    24,    35,    18,    21,    42,    19,     1,
    49 ]

racc_action_pointer = [
    -2,    49,    12,   nil,   nil,   nil,   nil,   nil,    30,     9,
   nil,   nil,   nil,   nil,   nil,   nil,    20,   nil,    38,    40,
   nil,    37,   nil,   nil,    31,   nil,    21,   nil,    17,   nil,
    27,   nil,   nil,    -4,   nil,    44,   nil,   nil,    24,   nil,
    -5,   nil,    40,   nil,   nil,   nil,   nil,    27,    18,    37,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil ]

racc_action_default = [
   -50,   -50,    -1,    -2,    -4,    -5,    -6,    -7,    -8,    -9,
   -10,   -11,   -12,   -13,   -14,   -15,   -16,   -17,   -22,   -23,
   -24,   -26,   -27,   -29,   -31,   -32,   -50,   -34,   -36,   -40,
   -42,   -43,   -45,   -47,   -48,   -50,    -3,   -30,   -50,   -41,
   -50,   -18,   -19,   -20,   -25,   -28,   -35,   -50,   -50,   -37,
   -38,   -46,   -49,    58,   -21,   -33,   -44,   -39 ]

racc_goto_table = [
    39,    37,    48,    47,     3,    42,    36,     2,    46,    49,
     1,   nil,   nil,   nil,   nil,    47,    48,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,    39,
    37 ]

racc_goto_check = [
    22,    17,     9,     8,     3,    14,     3,     2,    20,    21,
     1,   nil,   nil,   nil,   nil,     8,     9,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,    22,
    17 ]

racc_goto_pointer = [
   nil,    10,     7,     4,   nil,   nil,   nil,   nil,   -23,   -24,
   nil,   nil,   nil,   nil,   -13,   nil,   nil,    -7,   nil,   nil,
   -16,   -19,    -9,   nil,   nil,   nil ]

racc_goto_default = [
   nil,   nil,   nil,   nil,     4,     5,     6,     7,     8,     9,
    10,    11,    12,    16,   nil,    19,    21,    23,    24,    25,
    27,   nil,    29,    30,    31,    33 ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 18, :_reduce_1,
  1, 19, :_reduce_2,
  2, 19, :_reduce_3,
  1, 20, :_reduce_none,
  1, 20, :_reduce_5,
  1, 20, :_reduce_none,
  1, 20, :_reduce_none,
  1, 20, :_reduce_8,
  1, 20, :_reduce_9,
  1, 20, :_reduce_none,
  1, 20, :_reduce_none,
  1, 20, :_reduce_none,
  1, 20, :_reduce_13,
  1, 21, :_reduce_14,
  1, 29, :_reduce_15,
  1, 22, :_reduce_16,
  1, 30, :_reduce_17,
  2, 30, :_reduce_18,
  2, 27, :_reduce_19,
  1, 31, :_reduce_20,
  2, 31, :_reduce_21,
  0, 31, :_reduce_none,
  1, 23, :_reduce_23,
  1, 32, :_reduce_24,
  2, 32, :_reduce_25,
  1, 24, :_reduce_26,
  1, 33, :_reduce_27,
  2, 33, :_reduce_28,
  1, 25, :_reduce_29,
  2, 25, :_reduce_30,
  1, 34, :_reduce_31,
  1, 34, :_reduce_32,
  3, 36, :_reduce_33,
  1, 35, :_reduce_34,
  2, 35, :_reduce_35,
  1, 37, :_reduce_36,
  2, 37, :_reduce_37,
  1, 38, :_reduce_38,
  2, 38, :_reduce_39,
  1, 26, :_reduce_40,
  2, 26, :_reduce_41,
  1, 39, :_reduce_42,
  1, 39, :_reduce_43,
  3, 41, :_reduce_44,
  1, 40, :_reduce_45,
  2, 40, :_reduce_46,
  1, 28, :_reduce_47,
  1, 42, :_reduce_48,
  2, 42, :_reduce_49 ]

racc_reduce_n = 50

racc_shift_n = 58

racc_token_table = {
  false => 0,
  :error => 1,
  :HEADER => 2,
  :WHITELINE => 3,
  :HEADLINE => 4,
  :PLAIN => 5,
  :DESCLINE_TITLE => 6,
  :DESCLINE => 7,
  :PREFORMAT => 8,
  :QUOTE => 9,
  :INDENT => 10,
  :DEDENT => 11,
  :ITEMLIST => 12,
  :ITEMLISTCONTINUE => 13,
  :NUMLIST => 14,
  :TABLELINE => 15,
  :DUMMY => 16 }

racc_nt_base = 17

racc_use_result_var = false

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "HEADER",
  "WHITELINE",
  "HEADLINE",
  "PLAIN",
  "DESCLINE_TITLE",
  "DESCLINE",
  "PREFORMAT",
  "QUOTE",
  "INDENT",
  "DEDENT",
  "ITEMLIST",
  "ITEMLISTCONTINUE",
  "NUMLIST",
  "TABLELINE",
  "DUMMY",
  "$start",
  "document",
  "blocks",
  "block",
  "header",
  "paragraph",
  "preformat_block",
  "quote_block",
  "itemlist_blocks",
  "numlist_blocks",
  "desc_block",
  "table_block",
  "headline",
  "plain_texts",
  "desclines",
  "preformats",
  "quotes",
  "itemlist_block",
  "itemlists",
  "itemlist_indent_blocks",
  "itemlistitems",
  "itemlist_continues",
  "numlist_block",
  "numlists",
  "numlist_indent_blocks",
  "tablelines" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

module_eval(<<'.,.,', 'mokblockparser.ry', 10)
  def _reduce_1(val, _values)
     val[0].compact 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 12)
  def _reduce_2(val, _values)
     val 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 13)
  def _reduce_3(val, _values)
     [val[0], val[1]].flatten 
  end
.,.,

# reduce 4 omitted

module_eval(<<'.,.,', 'mokblockparser.ry', 16)
  def _reduce_5(val, _values)
     val[0] 
  end
.,.,

# reduce 6 omitted

# reduce 7 omitted

module_eval(<<'.,.,', 'mokblockparser.ry', 19)
  def _reduce_8(val, _values)
     ItemList.new(val[0].flatten) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 20)
  def _reduce_9(val, _values)
     NumList.new(val[0].flatten) 
  end
.,.,

# reduce 10 omitted

# reduce 11 omitted

# reduce 12 omitted

module_eval(<<'.,.,', 'mokblockparser.ry', 24)
  def _reduce_13(val, _values)
     WhiteLine.new 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 28)
  def _reduce_14(val, _values)
                 name, val = val[0].split(":",2)
             if name.nil? or val.nil?
             else
               @metadata.update({name.strip.to_sym => val.strip })
             end
             nil 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 36)
  def _reduce_15(val, _values)
     # val[0] is like [level, title, index]
                        title = val[0][1]
                        level = val[0][0]
                        if level == 1
                          @metadata[:subject] ||= title
                        else
                          @head_index.update(level)
                        end

                        @index[:head] ||= []
                        @index[:head] << {:title => title, :level => level, :index => @head_index.to_s}
                        HeadLine.new([level, title, @index[:head].size, @head_index.to_s]) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 49)
  def _reduce_16(val, _values)
     Paragraph.new @inline_parser.parse(val) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 51)
  def _reduce_17(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 52)
  def _reduce_18(val, _values)
     val[0] + val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 56)
  def _reduce_19(val, _values)
                     if val[1].nil?
                   lines = [Plain.new("")]
                 else
                   lines = @inline_parser.parse(val[1])
                 end
                 Desc.new([val[0], lines])
               
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 65)
  def _reduce_20(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 66)
  def _reduce_21(val, _values)
     val[0] + val[1] 
  end
.,.,

# reduce 22 omitted

module_eval(<<'.,.,', 'mokblockparser.ry', 71)
  def _reduce_23(val, _values)
     pr = val[0].strip  ; Preformat.new([pr]) unless pr.empty? 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 73)
  def _reduce_24(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 74)
  def _reduce_25(val, _values)
     val[0] + val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 78)
  def _reduce_26(val, _values)
     qu = val[0].strip  ; Quote.new(@inline_parser.parse(qu)) unless qu.empty? 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 80)
  def _reduce_27(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 81)
  def _reduce_28(val, _values)
     val[0] + val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 85)
  def _reduce_29(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 86)
  def _reduce_30(val, _values)
     val[0] << val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 88)
  def _reduce_31(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 89)
  def _reduce_32(val, _values)
     val[0]  
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 91)
  def _reduce_33(val, _values)
     val 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 93)
  def _reduce_34(val, _values)
    [PlainTextBlock.new(@inline_parser.parse(val[0]))]
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 94)
  def _reduce_35(val, _values)
     val[0] << PlainTextBlock.new(@inline_parser.parse(val[1])) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 96)
  def _reduce_36(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 97)
  def _reduce_37(val, _values)
     val[0] + val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 99)
  def _reduce_38(val, _values)
     "\n" + val[0]  
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 100)
  def _reduce_39(val, _values)
     val[0] + "\n" + val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 104)
  def _reduce_40(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 105)
  def _reduce_41(val, _values)
     val[0] << val[1] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 107)
  def _reduce_42(val, _values)
     val[0] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 108)
  def _reduce_43(val, _values)
     val[0]  
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 110)
  def _reduce_44(val, _values)
     val 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 112)
  def _reduce_45(val, _values)
     [PlainTextBlock.new(@inline_parser.parse(val[0]))] 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 113)
  def _reduce_46(val, _values)
     val[0] << PlainTextBlock.new(@inline_parser.parse(val[1])) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 118)
  def _reduce_47(val, _values)
     Table.new(val[0]) 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 120)
  def _reduce_48(val, _values)
      val 
  end
.,.,

module_eval(<<'.,.,', 'mokblockparser.ry', 121)
  def _reduce_49(val, _values)
     val[0] << val[1] 
  end
.,.,

def _reduce_none(val, _values)
  val[0]
end

end   # class BlockParser

  if __FILE__ == $0
    mok = BlockParser.new
    src = $stdin.readlines
    nodes = mok.parse(src)
    puts "----- index -----"
    mok.index.each do |key,val|
      puts key
      val.each do |v| p v end
    end
    puts "----- info -----"
    p mok.info
    puts "----- output -----"
    nodes.each do |n|
      puts n.apply
    end
  end
end # end of module Mok
